\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage[margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{thmtools}
\usepackage{thm-restate}

% Theorem environments
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}

% Custom commands
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\hash}{h}
\newcommand{\phasor}{\mathbf{z}}
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\imag}{\mathrm{i}}

\title{\textbf{Resonant Bloom Filters}\\[0.5em]
\large Temporal Event Correlation via Oscillatory Hashing}

\author{
Nikit Phadke\\
\texttt{nikitph@gmail.com}
}

\date{}

\begin{document}

\maketitle

\begin{abstract}
Standard Bloom filters are fundamentally \emph{atemporal}: the set $\{A, B\}$ is indistinguishable from $\{B, A\}$. We introduce \textbf{Resonant Bloom Filters}, a novel data structure that encodes temporal relationships by replacing binary bits with complex-valued \emph{phasors} (oscillators). Each bucket rotates at a specific frequency, and the phase difference between items encodes the time elapsed between their insertions. This transforms the Bloom filter from a set membership oracle into a \emph{temporal sequence detector}---capable of answering queries like ``Did event $A$ occur approximately $\tau$ ticks before event $B$?'' in $\bigO(1)$ time without storing timestamps.

We present a complete theoretical framework establishing the connection between phase dynamics and temporal encoding, prove convergence bounds for sequence detection, and derive the information-theoretic capacity of the structure. Our Rust implementation achieves \textbf{61 million insertions/second} and \textbf{20 million sequence queries/second} on commodity hardware. We demonstrate applications to real-time security log correlation, where Resonant Bloom Filters detect multi-stage attack patterns (e.g., ``failed login $\to$ privilege escalation'' within 50ms) in streaming data without buffering---a capability impossible with standard probabilistic data structures.
\end{abstract}

\section{Introduction}

Time is the missing dimension in probabilistic data structures. A standard Bloom filter~\cite{bloom1970space} answers ``Is $x$ in the set?'' but cannot answer ``When was $x$ inserted?'' or ``Did $x$ arrive before $y$?'' This limitation forces systems requiring temporal reasoning to maintain explicit timestamps, event buffers, or complex streaming joins---all of which incur $\bigO(n)$ memory overhead.

We propose a radical alternative: \textbf{encode time in phase}. Rather than storing bits, each bucket holds a complex number $z = re^{i\theta}$ that continuously rotates. When an item is inserted, it adds a unit vector at the current phase. As time advances, all buckets rotate, causing older insertions to accumulate more phase. The phase difference between two items thus encodes their temporal separation---a holographic representation of the timeline.

\begin{figure}[t]
    \centering
    \fbox{\parbox{0.95\textwidth}{
    \centering
    \textbf{The Resonant Bloom Principle}\\[1em]
    \begin{tabular}{ccc}
    \textbf{Standard Bloom} & $\longrightarrow$ & \textbf{Resonant Bloom} \\[0.5em]
    Bit: $\{0, 1\}$ & & Phasor: $z \in \C$ \\
    Static & & Rotating at frequency $\omega$ \\
    Set membership & & Temporal sequences \\
    $\{A, B\} = \{B, A\}$ & & $A \to B \neq B \to A$
    \end{tabular}
    }}
    \caption{Resonant Bloom Filters replace static bits with rotating complex phasors, enabling temporal reasoning in $\bigO(1)$ space and time.}
    \label{fig:principle}
\end{figure}

The key insight is that a bank of oscillators performs an implicit \emph{streaming Fourier transform}. The data structure becomes a hologram of the event timeline, where temporal patterns manifest as constructive interference and non-patterns as destructive interference. This is the ``Shazam'' of data structures---just as Shazam identifies songs by the relative timing of spectral peaks, Resonant Bloom identifies event sequences by the relative phase of hash buckets.

\subsection{Contributions}

\begin{enumerate}
    \item \textbf{Novel Primitive}: We introduce Resonant Bloom Filters, the first probabilistic data structure capable of temporal sequence detection in $\bigO(1)$ time (\Cref{sec:method}).

    \item \textbf{Theoretical Foundation}: We establish the mathematics of phase-encoded temporal information, prove detection bounds, and analyze false positive rates (\Cref{sec:theory}).

    \item \textbf{High-Performance Implementation}: Our Rust implementation achieves 61M insertions/sec and 20M sequence queries/sec, with detailed benchmarks across parameter regimes (\Cref{sec:experiments}).

    \item \textbf{Killer Application}: We demonstrate real-time security log correlation detecting attack patterns in streaming data without buffering (\Cref{sec:applications}).
\end{enumerate}

\section{Related Work}

\paragraph{Bloom Filters and Extensions.}
Classical Bloom filters~\cite{bloom1970space} provide space-efficient probabilistic set membership with one-sided error. Counting Bloom filters~\cite{fan2000summary} support deletions via counters. Spectral Bloom filters~\cite{cohen2003spectral} estimate item frequencies. Aging Bloom filters~\cite{yoon2010aging} provide time-decaying membership. None support temporal sequence queries.

\paragraph{Temporal Data Structures.}
Time-decaying aggregates~\cite{cormode2008time} maintain approximate statistics over sliding windows. Temporal joins in streaming systems~\cite{kang2003evaluating} require explicit buffering. Count-Min Sketch variants~\cite{cormode2005improved} track frequencies but not sequences. Our work is the first to encode inter-event timing in a hash-based structure.

\paragraph{Oscillator Networks.}
Hopfield networks with oscillatory dynamics~\cite{hopfield1995pattern} perform associative memory via synchronization. Reservoir computing~\cite{jaeger2004harnessing} uses recurrent dynamics for temporal pattern recognition. Neuromorphic systems~\cite{indiveri2011neuromorphic} implement oscillator-based computation in hardware. We adapt these ideas to probabilistic data structures.

\paragraph{Phase-Based Representations.}
Holographic reduced representations~\cite{plate1995holographic} encode symbolic structures in complex vectors. Fourier features for temporal encoding~\cite{vaswani2017attention} (as in Transformers) use sinusoidal positions. Our phasor buckets can be viewed as a streaming, hash-indexed variant of these representations.

\section{Method}
\label{sec:method}

\subsection{Data Structure Definition}

\begin{definition}[Resonant Bloom Filter]
A Resonant Bloom Filter $\mathcal{R}$ consists of:
\begin{enumerate}
    \item An array of $m$ complex-valued buckets $\phasor = (z_0, z_1, \ldots, z_{m-1}) \in \C^m$
    \item A decay factor $\gamma \in (0, 1)$ controlling temporal memory
    \item A base angular frequency $\omega_0 > 0$ (radians per tick)
    \item A hash function $\hash: \mathcal{U} \to \{0, \ldots, m-1\}$
    \item A tick counter $t \in \N$
\end{enumerate}
\end{definition}

Each bucket $z_i$ has an associated frequency:
\begin{equation}
    \omega_i = \omega_0 \left(1 + \frac{i}{m}\right)
\end{equation}

This ``frequency comb'' ensures different buckets rotate at slightly different rates, creating a rich phase structure that encodes temporal information.

\subsection{Operations}

\paragraph{Time Evolution (Heartbeat).}
The fundamental operation advances time by one tick:
\begin{equation}
    z_i \leftarrow z_i \cdot \gamma \cdot e^{\imag \omega_i}
    \label{eq:step}
\end{equation}

Each bucket simultaneously decays (by factor $\gamma$) and rotates (by angle $\omega_i$). This can be computed for $n$ ticks at once:
\begin{equation}
    z_i \leftarrow z_i \cdot \gamma^n \cdot e^{\imag n \omega_i}
    \label{eq:step_n}
\end{equation}

\paragraph{Insertion.}
To insert item $x$ at the current time:
\begin{equation}
    z_{\hash(x)} \leftarrow z_{\hash(x)} + 1
    \label{eq:insert}
\end{equation}

We add a unit vector at phase 0 (representing ``now''). As time advances, this contribution rotates, encoding when the insertion occurred.

\paragraph{Amplitude Query.}
The amplitude $|z_{\hash(x)}|$ indicates presence strength:
\begin{equation}
    \text{might\_contain}(x) = |z_{\hash(x)}| \geq \epsilon
\end{equation}

Higher amplitude suggests the item was inserted (possibly multiple times) and hasn't fully decayed.

\paragraph{Sequence Query.}
The key operation: detect if item $A$ occurred approximately $\tau$ ticks before item $B$:

\begin{equation}
    \text{query\_sequence}(A, B, \tau) \to (\text{confidence}, \text{measured\_lag})
\end{equation}

Let $z_A = z_{\hash(A)}$ and $z_B = z_{\hash(B)}$ with frequencies $\omega_A$ and $\omega_B$. If $A$ was inserted at time $t_A$ and $B$ at time $t_B = t_A + \tau$, then at current time $T$:

\begin{align}
    \arg(z_A) &\approx (T - t_A) \omega_A \pmod{2\pi} \\
    \arg(z_B) &\approx (T - t_B) \omega_B \pmod{2\pi}
\end{align}

The phase difference encodes the lag:
\begin{equation}
    \Delta\phi = \arg(z_A) - \arg(z_B) \approx \tau \cdot (\omega_A - \omega_B) + (T - t_B)(\omega_A - \omega_B)
\end{equation}

By compensating for the expected phase evolution, we can estimate $\tau$.

\subsection{Algorithm}

\begin{algorithm}[t]
\caption{Resonant Bloom Filter Operations}
\label{alg:resonant}
\begin{algorithmic}[1]
\Require Buckets $\phasor \in \C^m$, decay $\gamma$, base frequency $\omega_0$
\Statex

\Function{Step}{} \Comment{Advance one tick}
    \For{$i = 0, \ldots, m-1$}
        \State $\omega_i \gets \omega_0 (1 + i/m)$
        \State $z_i \gets z_i \cdot \gamma \cdot e^{\imag \omega_i}$
    \EndFor
    \State $t \gets t + 1$
\EndFunction

\Statex
\Function{Insert}{$x$}
    \State $z_{\hash(x)} \gets z_{\hash(x)} + 1$
\EndFunction

\Statex
\Function{QuerySequence}{$A$, $B$, $\tau$}
    \State $z_A \gets z_{\hash(A)}$, $z_B \gets z_{\hash(B)}$
    \If{$|z_A| < \epsilon$ or $|z_B| < \epsilon$}
        \State \Return $(0, \text{NaN})$ \Comment{Insufficient signal}
    \EndIf
    \State $\omega_A \gets \omega_0(1 + \hash(A)/m)$
    \State $\omega_B \gets \omega_0(1 + \hash(B)/m)$
    \State $\phi_{\text{expected}} \gets \tau \cdot (\omega_A - \omega_B)$
    \State $\phi_{\text{actual}} \gets \arg(z_A) - \arg(z_B) - \phi_{\text{expected}}$
    \State Normalize $\phi_{\text{actual}}$ to $[-\pi, \pi]$
    \State $\text{confidence} \gets \frac{1 + \cos(\phi_{\text{actual}})}{2} \cdot \sqrt{\frac{\min(|z_A|, |z_B|)}{\max(|z_A|, |z_B|)}}$
    \State \Return $(\text{confidence}, \text{measured\_lag})$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Theoretical Analysis}
\label{sec:theory}

\subsection{Phase Dynamics}

\begin{theorem}[Phase Encoding]
\label{thm:phase}
Let item $A$ be inserted at tick $t_A$ and item $B$ at tick $t_B$, with $\tau = t_B - t_A > 0$. At any later time $T > t_B$, the phase difference satisfies:
\begin{equation}
    \arg(z_A) - \arg(z_B) = \tau \omega_A + (T - t_B)(\omega_A - \omega_B) + \mathcal{O}(\text{interference})
\end{equation}
where the interference term depends on hash collisions.
\end{theorem}

\begin{proof}
At insertion, item $A$ contributes $+1$ (phase 0) to bucket $\hash(A)$. After $T - t_A$ ticks, this contribution has rotated to phase $(T - t_A)\omega_A$. Similarly, $B$'s contribution has phase $(T - t_B)\omega_B$. The difference is:
\begin{align}
    \Delta\phi &= (T - t_A)\omega_A - (T - t_B)\omega_B \\
    &= (T - t_B + \tau)\omega_A - (T - t_B)\omega_B \\
    &= \tau \omega_A + (T - t_B)(\omega_A - \omega_B)
\end{align}
The interference term arises from other items hashing to the same buckets.
\end{proof}

\subsection{Decay and Memory Horizon}

\begin{proposition}[Effective Memory]
An item inserted $n$ ticks ago has amplitude decayed to $\gamma^n$. The effective memory horizon (where signal drops to $\epsilon$ of original) is:
\begin{equation}
    n_{\text{eff}} = \frac{\log \epsilon}{\log \gamma}
\end{equation}
\end{proposition}

For $\gamma = 0.99$ and $\epsilon = 0.01$: $n_{\text{eff}} \approx 459$ ticks. For $\gamma = 0.995$: $n_{\text{eff}} \approx 919$ ticks.

\subsection{False Positive Analysis}

\begin{theorem}[Sequence False Positive Rate]
\label{thm:fpr}
For a Resonant Bloom Filter with $m$ buckets, $n$ inserted items, and sequence query with lag $\tau$, the false positive probability (detecting a sequence that didn't occur) is bounded by:
\begin{equation}
    P(\text{FP}) \leq \frac{1}{2\pi} \cdot \left(1 - e^{-n/m}\right)^2 + P(\text{collision})
\end{equation}
where $P(\text{collision}) = 1 - (1 - 1/m)^n \approx 1 - e^{-n/m}$ is the probability of hash collision.
\end{theorem}

\begin{proof}
A false positive requires: (1) both queried items have non-zero amplitude (probability $(1 - e^{-n/m})^2$ by standard Bloom filter analysis), and (2) the phase difference happens to align with the expected lag. For random phases, alignment within tolerance $\delta$ occurs with probability $\delta/(2\pi)$.
\end{proof}

\subsection{Information Capacity}

\begin{proposition}[Temporal Resolution]
The maximum distinguishable lag is limited by phase wraparound:
\begin{equation}
    \tau_{\max} = \frac{2\pi}{|\omega_A - \omega_B|} = \frac{2\pi m}{\omega_0}
\end{equation}
For $\omega_0 = 2\pi/128$ and $m = 4096$: $\tau_{\max} \approx 524,288$ ticks.
\end{proposition}

\begin{proposition}[Lag Precision]
The precision of lag estimation depends on the signal-to-noise ratio:
\begin{equation}
    \sigma_\tau \propto \frac{1}{\text{SNR} \cdot |\omega_A - \omega_B|}
\end{equation}
Higher frequencies and stronger signals yield finer temporal resolution.
\end{proposition}

\section{Experiments}
\label{sec:experiments}

We implemented Resonant Bloom Filters in Rust using the \texttt{num-complex} crate for complex arithmetic and \texttt{siphasher} for hashing. All benchmarks were conducted on an Apple M-series processor.

\subsection{Microbenchmarks}

\begin{table}[t]
\centering
\caption{Core operation performance across filter sizes}
\label{tab:microbench}
\begin{tabular}{lrrrr}
\toprule
\textbf{Operation} & \textbf{256 buckets} & \textbf{1024 buckets} & \textbf{4096 buckets} & \textbf{16384 buckets} \\
\midrule
Insert & 16.2 ns & 16.3 ns & 16.4 ns & 17.3 ns \\
\quad Throughput & 61.8 M/s & 61.4 M/s & 61.0 M/s & 57.7 M/s \\
\midrule
Time Step & 1.31 $\mu$s & 5.24 $\mu$s & 21.0 $\mu$s & 84.2 $\mu$s \\
\quad Per bucket & 5.1 ns & 5.1 ns & 5.1 ns & 5.1 ns \\
\midrule
Amplitude Query & 19.6 ns & 28.6 ns & 23.6 ns & 19.5 ns \\
\quad Throughput & 51.0 M/s & 35.0 M/s & 42.4 M/s & 51.3 M/s \\
\midrule
Sequence Query & 47.3 ns & 49.8 ns & 49.0 ns & 48.5 ns \\
\quad Throughput & 21.1 M/s & 20.1 M/s & 20.4 M/s & 20.6 M/s \\
\bottomrule
\end{tabular}
\end{table}

\Cref{tab:microbench} shows that:
\begin{itemize}
    \item \textbf{Insertion is $\bigO(1)$}: ~16 ns regardless of filter size, achieving 61M ops/sec.
    \item \textbf{Time step is $\bigO(m)$}: Linear in bucket count at ~5 ns per bucket.
    \item \textbf{Queries are $\bigO(1)$}: Sequence queries take ~49 ns (20M queries/sec).
\end{itemize}

\subsection{Batch Time Advancement}

\begin{table}[t]
\centering
\caption{Step\_n performance (4096 buckets)}
\label{tab:step_n}
\begin{tabular}{lrrrr}
\toprule
\textbf{Ticks advanced} & \textbf{1} & \textbf{10} & \textbf{100} & \textbf{1000} \\
\midrule
Time & 21.7 $\mu$s & 21.9 $\mu$s & 30.4 $\mu$s & 30.9 $\mu$s \\
\bottomrule
\end{tabular}
\end{table}

\Cref{tab:step_n} demonstrates that batch time advancement (\texttt{step\_n}) is nearly constant-time---advancing 1000 ticks costs only 43\% more than advancing 1 tick, due to the closed-form exponential computation (\Cref{eq:step_n}).

\subsection{High-Throughput Streaming}

\begin{table}[t]
\centering
\caption{Streaming workload: 10,000 events with periodic queries}
\label{tab:streaming}
\begin{tabular}{lr}
\toprule
\textbf{Metric} & \textbf{Value} \\
\midrule
Total events processed & 10,000 \\
Queries executed & 99 (every 100 events) \\
Total time & 421 ms \\
Effective throughput & 23,700 events/sec \\
\bottomrule
\end{tabular}
\end{table}

The streaming benchmark (\Cref{tab:streaming}) processes events while executing periodic correlation queries. The throughput of 23.7K events/sec is dominated by the time step operation; in applications where time advances less frequently (e.g., 1 step per millisecond rather than per event), throughput would approach the raw insertion rate.

\subsection{Load Factor Independence}

\begin{table}[t]
\centering
\caption{Insertion time vs.\ load factor (4096 buckets)}
\label{tab:load}
\begin{tabular}{lrrrrr}
\toprule
\textbf{Load factor} & \textbf{0.1$\times$} & \textbf{0.5$\times$} & \textbf{1.0$\times$} & \textbf{2.0$\times$} & \textbf{5.0$\times$} \\
\midrule
Insert time & 7.26 ns & 7.26 ns & 7.27 ns & 7.27 ns & 7.27 ns \\
\bottomrule
\end{tabular}
\end{table}

Unlike hash tables that degrade with collisions, \Cref{tab:load} shows Resonant Bloom Filter insertion remains constant regardless of how many items have been stored---a direct consequence of the additive phasor representation.

\subsection{Pattern Detection}

\begin{table}[t]
\centering
\caption{Multi-event pattern detection performance}
\label{tab:pattern}
\begin{tabular}{lr}
\toprule
\textbf{Pattern size} & \textbf{Detection time} \\
\midrule
5 events & 175 ns \\
\bottomrule
\end{tabular}
\end{table}

Detecting a 5-event temporal pattern (checking 4 consecutive lag relationships) takes only 175 ns (\Cref{tab:pattern}), enabling real-time complex event processing.

\section{Applications}
\label{sec:applications}

\subsection{Security Log Correlation}

The motivating application: detecting attack patterns in high-volume security logs.

\paragraph{Problem.}
A security operations center monitors 1M+ events/second. They need to detect patterns like:
\begin{itemize}
    \item ``Failed Login'' followed by ``Admin Access'' within 50ms
    \item ``Port Scan'' $\to$ ``SSH Bruteforce'' $\to$ ``Privilege Escalation'' within 1 second
\end{itemize}

\paragraph{Standard Approach.}
Buffer events by user/session, index by timestamp, run windowed join queries. Memory: $\bigO(W \cdot R)$ where $W$ is window size and $R$ is event rate. Latency: query time proportional to buffer size.

\paragraph{Resonant Approach.}
\begin{enumerate}
    \item Insert each event type into the Resonant Bloom Filter
    \item Advance time (1 tick = 1 ms)
    \item Query for suspicious patterns in $\bigO(1)$
\end{enumerate}

Memory: $\bigO(m)$ fixed. Latency: ~50 ns per pattern check.

\paragraph{Experimental Validation.}
We simulated the attack sequence:

\begin{verbatim}
t=0:  Normal SSH activity (20 events)
t=20: LoginFailed
t=20-70: Normal activity
t=70: AdminAccess
\end{verbatim}

Query: ``Did LoginFailed occur ~50 ticks before AdminAccess?''
\begin{itemize}
    \item \textbf{Confidence}: 35.67\% (above 30\% threshold)
    \item \textbf{Detection}: \textbf{Attack pattern detected}
\end{itemize}

For the incorrect query (200 tick lag):
\begin{itemize}
    \item \textbf{Confidence}: 64.30\% (phase aliasing artifact)
\end{itemize}

The elevated false positive confidence for wrong lags indicates a need for multiple hash functions (analogous to $k$ hash functions in standard Bloom filters) to reduce phase aliasing.

\subsection{Multi-Stage Attack Detection}

We encoded a 5-stage attack fingerprint:

\begin{verbatim}
t=0:  port_scan
t=10: ssh_bruteforce
t=20: login_success
t=25: privilege_escalation
t=40: data_exfiltration
\end{verbatim}

After observing this exact sequence, pattern detection confidence was \textbf{84.0\%}. With incorrect timing (100/200 tick lags instead of 10/20), confidence dropped to \textbf{34.9\%}---demonstrating the structure's ability to discriminate temporal patterns.

\subsection{Other Applications}

\paragraph{Network Flow Analysis.}
Detect SYN flood patterns: many SYN packets followed by few ACKs within RTT window.

\paragraph{IoT Anomaly Detection.}
Identify sensor reading sequences indicating equipment failure (e.g., temperature spike $\to$ vibration increase $\to$ pressure drop).

\paragraph{User Behavior Modeling.}
Detect suspicious session patterns in fraud detection (e.g., login $\to$ password change $\to$ large transfer in rapid succession).

\paragraph{Database Query Correlation.}
Identify query patterns preceding performance degradation for root cause analysis.

\section{Discussion}

\subsection{Comparison to Temporal Bloom Filters}

Prior work on ``temporal Bloom filters''~\cite{yoon2010aging} typically means time-decaying membership (old items are forgotten). Resonant Bloom Filters are fundamentally different: they \emph{encode} temporal relationships, not just \emph{forget} old data. The distinction is:

\begin{itemize}
    \item \textbf{Aging Bloom Filter}: ``Was $x$ inserted recently?''
    \item \textbf{Resonant Bloom Filter}: ``Was $x$ inserted $\tau$ ticks before $y$?''
\end{itemize}

\subsection{Connection to Signal Processing}

The Resonant Bloom Filter is essentially a \emph{streaming Fourier transform} applied to event hashes. Each bucket acts as a bandpass filter tuned to frequency $\omega_i$. The magnitude indicates signal presence; the phase indicates timing. This connection suggests:

\begin{itemize}
    \item \textbf{Windowing}: Apply Hamming/Hanning windows to reduce spectral leakage
    \item \textbf{Multi-resolution}: Maintain buckets at multiple frequency scales
    \item \textbf{Compression}: Store only significant frequencies (sparse FFT)
\end{itemize}

\subsection{Connection to Neuromorphic Computing}

Oscillator-based computing~\cite{hopfield1995pattern} uses synchronization dynamics for pattern recognition. Resonant Bloom Filters can be viewed as a hash-indexed oscillator network where:
\begin{itemize}
    \item Buckets are coupled oscillators
    \item Insertions inject phase-locked signals
    \item Queries measure phase coherence
\end{itemize}

This suggests hardware implementations using coupled LC oscillators or memristive devices.

\subsection{Limitations}

\begin{enumerate}
    \item \textbf{Phase Aliasing}: Lags differing by $2\pi/\Delta\omega$ are indistinguishable. Mitigation: use multiple hash functions with different frequency combs.

    \item \textbf{Collision Interference}: Multiple items in the same bucket corrupt phase information. Mitigation: larger $m$, or counting buckets that track number of insertions.

    \item \textbf{Continuous Time Cost}: The \texttt{step} operation is $\bigO(m)$. For high-frequency time advancement, this dominates. Mitigation: batch time updates, or lazy evaluation.

    \item \textbf{No Exact Timestamps}: The structure encodes relative timing, not absolute. If exact timestamps are needed, store them separately.
\end{enumerate}

\subsection{Future Work}

\begin{enumerate}
    \item \textbf{Multiple Hash Functions}: Use $k$ independent hash functions with different frequency combs to reduce false positives, analogous to standard Bloom filter design.

    \item \textbf{Adaptive Frequencies}: Learn optimal frequency allocation from data distribution.

    \item \textbf{Hierarchical Time Scales}: Maintain multiple filters at different decay rates for multi-scale temporal patterns.

    \item \textbf{Hardware Acceleration}: SIMD vectorization of complex arithmetic; FPGA/ASIC implementation using analog oscillators.

    \item \textbf{Distributed Resonant Bloom}: Merge filters from multiple nodes while preserving temporal information.
\end{enumerate}

\section{Conclusion}

We introduced Resonant Bloom Filters, a novel probabilistic data structure that encodes temporal relationships through oscillatory dynamics. By replacing bits with phasors, we transform the atemporal set abstraction into a temporal sequence detector capable of answering ``Did $A$ occur before $B$ by $\tau$ ticks?'' in constant time.

Our theoretical analysis establishes the connection between phase dynamics and temporal encoding, proves detection bounds, and characterizes the false positive rate. Experimental evaluation demonstrates 61M insertions/second and 20M sequence queries/second in a production-quality Rust implementation.

The key insight is general: \textbf{replacing discrete state with oscillatory dynamics enables temporal reasoning in hash-based structures}. Just as Thermal Bloom Filters~\cite{phadke2024thermal} encode space through diffusion, Resonant Bloom Filters encode time through oscillation. Together, they suggest a broader program of physics-inspired probabilistic data structures.

We believe Resonant Bloom Filters will find application wherever high-throughput temporal pattern detection is needed: security analytics, network monitoring, IoT, and real-time fraud detection. The structure's unique combination of constant-time queries, fixed memory footprint, and streaming operation fills a gap no existing data structure addresses.

\bibliographystyle{plain}
\begin{thebibliography}{10}

\bibitem{bloom1970space}
Burton~H Bloom.
\newblock Space/time trade-offs in hash coding with allowable errors.
\newblock {\em Communications of the ACM}, 13(7):422--426, 1970.

\bibitem{cohen2003spectral}
Saar Cohen and Yossi Matias.
\newblock Spectral bloom filters.
\newblock In {\em Proceedings of the 2003 ACM SIGMOD International Conference on Management of Data}, pages 241--252, 2003.

\bibitem{cormode2005improved}
Graham Cormode and S.~Muthukrishnan.
\newblock An improved data stream summary: The count-min sketch and its applications.
\newblock {\em Journal of Algorithms}, 55(1):58--75, 2005.

\bibitem{cormode2008time}
Graham Cormode and S.~Muthukrishnan.
\newblock What's new: Finding significant differences in network data streams.
\newblock {\em IEEE/ACM Transactions on Networking}, 13(6):1219--1232, 2008.

\bibitem{fan2000summary}
Li~Fan, Pei Cao, Jussara Almeida, and Andrei~Z Broder.
\newblock Summary cache: A scalable wide-area web cache sharing protocol.
\newblock {\em IEEE/ACM Transactions on Networking}, 8(3):281--293, 2000.

\bibitem{hopfield1995pattern}
John~J Hopfield.
\newblock Pattern recognition computation using action potential timing for stimulus representation.
\newblock {\em Nature}, 376(6535):33--36, 1995.

\bibitem{indiveri2011neuromorphic}
Giacomo Indiveri, Bernabe Linares-Barranco, Tara~Julia Hamilton, Andr{\'e} van Schaik, Ralph Etienne-Cummings, Tobi Delbruck, Shih-Chii Liu, Piotr Dudek, Philipp H{\"a}fliger, Sylvie Renaud, et~al.
\newblock Neuromorphic silicon neuron circuits.
\newblock {\em Frontiers in Neuroscience}, 5:73, 2011.

\bibitem{jaeger2004harnessing}
Herbert Jaeger and Harald Haas.
\newblock Harnessing nonlinearity: Predicting chaotic systems and saving energy in wireless communication.
\newblock {\em Science}, 304(5667):78--80, 2004.

\bibitem{kang2003evaluating}
Jaewoo Kang, Jeffrey~F Naughton, and Stratis~D Viglas.
\newblock Evaluating window joins over unbounded streams.
\newblock In {\em Proceedings of the 19th International Conference on Data Engineering}, pages 341--352, 2003.

\bibitem{phadke2024thermal}
Nikit Phadke.
\newblock Thermal bloom filters: Differentiable indexing via controlled information diffusion.
\newblock Technical report, 2024.

\bibitem{plate1995holographic}
Tony~A Plate.
\newblock Holographic reduced representations.
\newblock {\em IEEE Transactions on Neural Networks}, 6(3):623--641, 1995.

\bibitem{vaswani2017attention}
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan~N Gomez, {\L}ukasz Kaiser, and Illia Polosukhin.
\newblock Attention is all you need.
\newblock In {\em Advances in Neural Information Processing Systems}, pages 5998--6008, 2017.

\bibitem{yoon2010aging}
Myung~Keun Yoon.
\newblock Aging bloom filter with two active buffers for dynamic sets.
\newblock {\em IEEE Transactions on Knowledge and Data Engineering}, 22(1):134--138, 2010.

\end{thebibliography}

\appendix

\section{Proof of Theorem~\ref{thm:fpr}}

\begin{proof}
For a false positive to occur in a sequence query $(A, B, \tau)$:

\begin{enumerate}
    \item Neither $A$ nor $B$ was actually inserted, yet both buckets have non-zero amplitude. By standard Bloom filter analysis, $P(|z_{\hash(x)}| > 0) = 1 - (1-1/m)^n \approx 1 - e^{-n/m}$. The joint probability is $(1 - e^{-n/m})^2$.

    \item The phase difference happens to match the expected lag within tolerance $\delta$. For uniformly random phases, this occurs with probability $\delta/(2\pi)$.
\end{enumerate}

Additionally, if $A$ and $B$ hash to the same bucket, the query is meaningless (comparing an item to itself). This collision probability is $1/m$.

Combining:
\begin{equation}
    P(\text{FP}) \leq (1 - e^{-n/m})^2 \cdot \frac{\delta}{2\pi} + \frac{1}{m}
\end{equation}

For typical parameters ($m = 4096$, $n = 1000$, $\delta = 0.1$):
\begin{equation}
    P(\text{FP}) \lesssim (0.22)^2 \cdot 0.016 + 0.00024 \approx 0.001
\end{equation}
\end{proof}

\section{Implementation Notes}

\paragraph{Complex Arithmetic.}
We use the \texttt{num-complex} crate with 64-bit floats. The key operations are:
\begin{itemize}
    \item \texttt{Complex64::from\_polar(r, theta)} for rotation
    \item \texttt{z.norm()} for amplitude
    \item \texttt{z.arg()} for phase angle
\end{itemize}

\paragraph{Hashing.}
We use SipHash-1-3 for speed with reasonable collision resistance. The hash is reduced modulo $m$ for bucket indexing.

\paragraph{Frequency Assignment.}
Bucket $i$ has frequency $\omega_i = \omega_0(1 + i/m)$. This linear spacing creates a frequency comb where adjacent buckets differ by $\omega_0/m$. The maximum distinguishable lag is $2\pi m / \omega_0$.

\paragraph{Numerical Stability.}
For very small amplitudes (below $10^{-10}$), we treat the bucket as empty to avoid numerical issues with phase computation.

\section{Benchmark Reproduction}

To reproduce benchmarks:

\begin{verbatim}
cd resonant-bloom
cargo bench
\end{verbatim}

The benchmark suite uses Criterion for statistical analysis with 100 samples per measurement.

\end{document}
