"""
FR-8: LLM Verbalization Guard

Verifies that generated text embedding stays within δ of selected meaning μ*.
Regenerates or refuses if drift detected.
"""

import numpy as np
from typing import List, Optional, Dict, Any, Tuple, Callable
from dataclasses import dataclass
from enum import Enum
from .semantic_space import SemanticSpace, Witness


class VerbalizationStatus(Enum):
    """Status of verbalization check."""
    VERIFIED = "verified"      # Within acceptable drift
    DRIFTED = "drifted"       # Exceeded drift threshold
    REGENERATE = "regenerate"  # Should try again
    REFUSE = "refuse"         # Too much drift, refuse to output


@dataclass
class VerbalizationResult:
    """Result of verbalization verification."""
    status: VerbalizationStatus
    original_meaning: np.ndarray
    generated_embedding: np.ndarray
    drift_distance: float
    drift_threshold: float
    attempts: int
    details: Dict[str, Any]


class VerbalizationGuard:
    """
    Guards against semantic drift in LLM verbalization.

    After selecting μ* from evidence, the LLM generates text.
    This guard re-embeds the text and verifies it hasn't drifted
    too far from μ*.

    Process:
    1. LLM generates response from μ*
    2. Re-embed response
    3. Compute angular distance to μ*
    4. If distance > δ: regenerate or refuse
    """

    def __init__(
        self,
        semantic_space: SemanticSpace,
        drift_threshold: float = 0.2,  # ~11 degrees
        max_regeneration_attempts: int = 3,
        strict_mode: bool = True
    ):
        """
        Args:
            semantic_space: Space for embedding generated text
            drift_threshold: Maximum angular distance (radians) allowed
            max_regeneration_attempts: How many times to try regenerating
            strict_mode: If True, refuse on drift. If False, warn but allow.
        """
        self.semantic_space = semantic_space
        self.drift_threshold = drift_threshold
        self.max_attempts = max_regeneration_attempts
        self.strict_mode = strict_mode

    def verify(
        self,
        original_meaning: np.ndarray,
        generated_text: str,
        witnesses: Optional[List[Witness]] = None
    ) -> VerbalizationResult:
        """
        Verify that generated text hasn't drifted from original meaning.

        Args:
            original_meaning: μ* selected by Mode B
            generated_text: Text generated by LLM
            witnesses: Original witnesses (for hull check)

        Returns:
            VerbalizationResult with status and metrics
        """
        # Embed generated text
        generated_embedding = self.semantic_space.embed(generated_text)

        # Compute angular distance
        drift_distance = self._angular_distance(original_meaning, generated_embedding)

        # Determine status
        if drift_distance <= self.drift_threshold:
            status = VerbalizationStatus.VERIFIED
        elif self.strict_mode:
            status = VerbalizationStatus.DRIFTED
        else:
            status = VerbalizationStatus.VERIFIED  # Warn but allow

        # Check if still in witness hull (if provided)
        in_hull = True
        hull_check = None
        if witnesses:
            in_hull, hull_check = self._check_hull_membership(
                generated_embedding, witnesses
            )
            if not in_hull and self.strict_mode:
                status = VerbalizationStatus.DRIFTED

        return VerbalizationResult(
            status=status,
            original_meaning=original_meaning,
            generated_embedding=generated_embedding,
            drift_distance=drift_distance,
            drift_threshold=self.drift_threshold,
            attempts=1,
            details={
                "in_hull": in_hull,
                "hull_check": hull_check,
                "drift_degrees": np.degrees(drift_distance),
                "threshold_degrees": np.degrees(self.drift_threshold),
                "strict_mode": self.strict_mode
            }
        )

    def verify_with_regeneration(
        self,
        original_meaning: np.ndarray,
        generate_fn: Callable[[], str],
        witnesses: Optional[List[Witness]] = None
    ) -> Tuple[VerbalizationResult, Optional[str]]:
        """
        Verify with automatic regeneration on drift.

        Args:
            original_meaning: μ* selected by Mode B
            generate_fn: Function that generates new text
            witnesses: Original witnesses

        Returns:
            (VerbalizationResult, final_text or None)
        """
        best_result = None
        best_text = None
        best_drift = float('inf')

        for attempt in range(self.max_attempts):
            generated_text = generate_fn()
            result = self.verify(original_meaning, generated_text, witnesses)

            # Track best attempt
            if result.drift_distance < best_drift:
                best_drift = result.drift_distance
                best_result = result
                best_text = generated_text

            # Success
            if result.status == VerbalizationStatus.VERIFIED:
                result.details['attempts'] = attempt + 1
                return result, generated_text

        # All attempts failed
        if best_result is not None:
            best_result.attempts = self.max_attempts
            best_result.status = VerbalizationStatus.REFUSE if self.strict_mode \
                else VerbalizationStatus.DRIFTED
            best_result.details['best_drift'] = best_drift
            best_result.details['all_attempts_failed'] = True

        return best_result, best_text if not self.strict_mode else None

    def _angular_distance(self, a: np.ndarray, b: np.ndarray) -> float:
        """Compute angular distance between two vectors."""
        a_norm = a / (np.linalg.norm(a) + 1e-10)
        b_norm = b / (np.linalg.norm(b) + 1e-10)
        dot = np.clip(np.dot(a_norm, b_norm), -1.0, 1.0)
        return float(np.arccos(dot))

    def _check_hull_membership(
        self,
        point: np.ndarray,
        witnesses: List[Witness]
    ) -> Tuple[bool, Dict[str, Any]]:
        """Check if point is in witness hull."""
        if len(witnesses) == 0:
            return True, {"message": "No witnesses"}

        point_norm = point / (np.linalg.norm(point) + 1e-10)
        W = np.array([w.embedding for w in witnesses])
        dots = W @ point_norm

        return bool(np.all(dots > 0)), {
            "min_dot": float(np.min(dots)),
            "mean_dot": float(np.mean(dots)),
            "violations": sum(1 for d in dots if d <= 0)
        }

    def compute_safe_generation_region(
        self,
        original_meaning: np.ndarray,
        witnesses: List[Witness]
    ) -> Dict[str, Any]:
        """
        Compute the region where generated text is considered safe.

        This helps inform LLM prompts about acceptable variation.
        """
        # Safe region is intersection of:
        # 1. Ball of radius δ around μ*
        # 2. Witness hull (all w · μ > 0)

        # Estimate by sampling
        n_samples = 1000
        safe_samples = []
        total_samples = []

        d = len(original_meaning)
        for _ in range(n_samples):
            # Sample in ball around μ*
            direction = np.random.randn(d)
            direction = direction / np.linalg.norm(direction)
            distance = np.random.uniform(0, self.drift_threshold)

            # Move along geodesic
            sample = np.cos(distance) * original_meaning + \
                     np.sin(distance) * direction
            sample = sample / np.linalg.norm(sample)

            total_samples.append(sample)

            # Check hull membership
            in_hull, _ = self._check_hull_membership(sample, witnesses)
            if in_hull:
                safe_samples.append(sample)

        safe_fraction = len(safe_samples) / n_samples

        return {
            "safe_fraction": safe_fraction,
            "drift_threshold": self.drift_threshold,
            "threshold_degrees": np.degrees(self.drift_threshold),
            "num_witnesses": len(witnesses),
            "recommendation": self._generation_recommendation(safe_fraction)
        }

    def _generation_recommendation(self, safe_fraction: float) -> str:
        """Generate recommendation based on safe fraction."""
        if safe_fraction > 0.9:
            return "Safe to generate with normal variance"
        elif safe_fraction > 0.5:
            return "Generate conservatively, staying close to evidence"
        else:
            return "Very constrained region - generate extremely conservatively"


class DriftDetector:
    """
    Monitors semantic drift across a conversation or session.
    """

    def __init__(self, semantic_space: SemanticSpace):
        self.semantic_space = semantic_space
        self.history: List[Tuple[np.ndarray, str]] = []  # (embedding, text)

    def add(self, text: str):
        """Add a response to drift history."""
        embedding = self.semantic_space.embed(text)
        self.history.append((embedding, text))

    def compute_drift(self) -> Dict[str, Any]:
        """Compute drift statistics over history."""
        if len(self.history) < 2:
            return {"drift": 0, "message": "Need at least 2 responses"}

        embeddings = np.array([h[0] for h in self.history])

        # Compute cumulative drift
        cumulative_drifts = []
        first_embedding = embeddings[0]

        for i, emb in enumerate(embeddings[1:], 1):
            dot = np.clip(np.dot(first_embedding, emb), -1.0, 1.0)
            drift = float(np.arccos(dot))
            cumulative_drifts.append(drift)

        # Compute consecutive drifts
        consecutive_drifts = []
        for i in range(1, len(embeddings)):
            dot = np.clip(np.dot(embeddings[i-1], embeddings[i]), -1.0, 1.0)
            drift = float(np.arccos(dot))
            consecutive_drifts.append(drift)

        return {
            "total_responses": len(self.history),
            "cumulative_drift": cumulative_drifts,
            "consecutive_drift": consecutive_drifts,
            "total_drift": cumulative_drifts[-1] if cumulative_drifts else 0,
            "mean_consecutive_drift": np.mean(consecutive_drifts) if consecutive_drifts else 0,
            "drift_rate": np.mean(consecutive_drifts) if consecutive_drifts else 0
        }

    def is_drifting(self, threshold: float = 0.5) -> bool:
        """Check if conversation is drifting excessively."""
        drift_stats = self.compute_drift()
        return drift_stats.get("total_drift", 0) > threshold

    def reset(self):
        """Reset drift history."""
        self.history = []
